#!/usr/bin/python3
# Image Recognition Using Tensorflow Exmaple.
# Code based on example at:
# https://raw.githubusercontent.com/tensorflow/tensorflow/master/tensorflow/examples/label_image/label_image.py
import os, base64

os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'
import tensorflow as tf

tf.logging.set_verbosity(tf.logging.ERROR)
import numpy as np
import threading
import queue
import time
import sys


# sudo apt install python3-pip
# sudo python3 -m pip install --upgrade pip
# sudo python3 -m pip install --upgrade setuptools
# sudo python3 -m pip install --upgrade tensorflow==1.15

class Classifier:
    def __init__(self):
        # tf.debugging.set_log_device_placement(True)
        self.graph = self.load_graph('./tmp/retrain_tmp/output_graph.pb')
        self.labels = self.load_labels("./tmp/retrain_tmp/output_labels.txt")

        self.input_operation = self.graph.get_operation_by_name("import/Placeholder")
        self.output_operation = self.graph.get_operation_by_name("import/final_result")
        self.sess = tf.compat.v1.Session(graph=self.graph)

    def load_labels(self, label_file):
        label = []
        proto_as_ascii_lines = tf.gfile.GFile(label_file).readlines()
        for l in proto_as_ascii_lines:
            label.append(l.rstrip())
        return label

    def predict_image(self, q, image_bytes, uuid):
        image = self.read_tensor_from_image_bytes(image_bytes)
        results = self.sess.run(self.output_operation.outputs[0], {
            self.input_operation.outputs[0]: image
        })
        results = np.squeeze(results)
        prediction = results.argsort()[-5:][::-1][0]
        q.put({'uuid': uuid, 'prediction': self.labels[prediction].title(), 'percent': results[prediction]})

    def load_graph(self, model_file):
        graph = tf.Graph()
        graph_def = tf.GraphDef()
        with open(model_file, "rb") as f:
            graph_def.ParseFromString(f.read())
        with graph.as_default():
            tf.import_graph_def(graph_def)
        return graph

    def read_tensor_from_image_bytes(self, imagebytes, input_height=299, input_width=299, input_mean=0, input_std=255):
        image_reader = tf.image.decode_png(imagebytes, channels=3, name="png_reader")
        float_caster = tf.cast(image_reader, tf.float32)
        dims_expander = tf.expand_dims(float_caster, 0)
        resized = tf.image.resize_bilinear(dims_expander, [input_height, input_width])
        normalized = tf.divide(tf.subtract(resized, [input_mean]), [input_std])
        sess = tf.compat.v1.Session()
        result = sess.run(normalized)
        return result

    def get_types(self, unsorted):
        # Can use queues and threading to spead up the processing
        print("Calculating image types")
        q = queue.Queue()

        # Going to interate over each of our images.
        for image in unsorted:
            # predict_image function is expecting png image bytes so we read image as 'rb' to get a bytes object
            image_bytes = base64.b64decode(image['base64'])
            image_uuid = image['uuid']
            threading.Thread(target=self.predict_image, args=(q, image_bytes, image_uuid)).start()

        print('Waiting For classification to Finish...')
        while q.qsize() < len(unsorted):
            time.sleep(0.001)

        # getting a list of all threads returned results
        prediction_results = [q.get() for x in range(q.qsize())]
        return prediction_results